<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - animation - keyframes</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			background-color: #bfe3dd;
			color: #000;
		}

		a {
			color: #2983ff;
		}
	</style>
</head>

<body>

<div id="container"></div>

<script type="module">

	import * as THREE from './js/three.module.js';

	import Stats from './three.js/examples/jsm/libs/stats.module.js';

	import { OrbitControls } from './three.js/examples/jsm/controls/OrbitControls.js';
	import { RoomEnvironment } from './three.js/examples/jsm/environments/RoomEnvironment.js';

	import { GLTFLoader } from './three.js/examples/jsm/loaders/GLTFLoader.js';
	import { DRACOLoader } from './three.js/examples/jsm/loaders/DRACOLoader.js';
	import {Vector3} from "./three.js/src/math/Vector3.js";

	let mixer;

	const clock = new THREE.Clock();
	const container = document.getElementById( 'container' );

	const stats = new Stats();
	container.appendChild( stats.dom );

	const renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.outputEncoding = THREE.sRGBEncoding;
	container.appendChild( renderer.domElement );

	const pmremGenerator = new THREE.PMREMGenerator( renderer );

	const scene = new THREE.Scene();
	scene.background = new THREE.Color( 0xbfe3dd );
	scene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;

	const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 100 );
	camera.position.set(10,10,20 );
	camera.lookAt(0,0,0);

	const controls = new OrbitControls( camera, renderer.domElement );
	controls.target.set( 0, 0.5, 0 );
	controls.update();
	controls.enablePan = true;
	controls.enableDamping = true;

	// 调试用坐标轴
	let axes = new THREE.AxesHelper(20);
	scene.add(axes);

	let vertices = [];
	let values = [];
	let loadedData = [];

	await readTextFile("./data.json", function(text){
		loadedData = JSON.parse(text);
		console.log(loadedData);
		console.log("Loaded " + (loadedData["infoList"].length).toString() +" sets of data" );
		const showResult = loadedData["infoList"][0]
		for( let x = 0 ; x < showResult["resultsList"].length ; x++){
			vertices.push(new THREE.Vector3(showResult["resultsList"][x]["locationX"],
					showResult["resultsList"][x]["locationY"],
					showResult["resultsList"][x]["locationZ"]));
			values.push(showResult["resultsList"][x]["value"])
		}
		// console.log(vertices);
		// console.log(values);
		let positions = [];
		let colors = [];
		for (let i = 0 ; i < vertices.length ; i++){
			positions.push(vertices[i].x, vertices[i].y , vertices[i].z);
			colors.push(Math.random(), Math.random(), Math.random());
			// console.log("add")
		}
		console.log(colors);
		let geometry = new THREE.BufferGeometry();
		geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
		geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));

		// geometry.computeBoundingSphere();
		// geometry.setDrawRange(0, vertices.length * 3 );
		const material = new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors , side:THREE.DoubleSide});

		const mesh = new THREE.Mesh(geometry, material);
		scene.add(mesh);
		console.log(geometry);
	});

	animate();

	// renderer.render(scene,camera);
	//
	// const dracoLoader = new DRACOLoader();
	// dracoLoader.setDecoderPath( 'js/libs/draco/gltf/' );
	//
	// const loader = new GLTFLoader();
	// loader.setDRACOLoader( dracoLoader );
	// loader.load( './three.js/examples/models/gltf/LittlestTokyo.glb', function ( gltf ) {
	//
	// 	const model = gltf.scene;
	// 	model.position.set( 1, 1, 0 );
	// 	model.scale.set( 0.01, 0.01, 0.01 );
	// 	scene.add( model );
	//
	// 	mixer = new THREE.AnimationMixer( model );
	// 	mixer.clipAction( gltf.animations[ 0 ] ).play();
	//
	// 	animate();
	//
	// }, undefined, function ( e ) {
	//
	// 	console.error( e );
	//
	// } );


	window.onresize = function () {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	};


	function animate() {

		requestAnimationFrame( animate );

		const delta = clock.getDelta();

		controls.update();

		stats.update();

		renderer.render( scene, camera );

	}

	async function readTextFile(file, callback){
		let rawFile = new XMLHttpRequest();
		rawFile.overrideMimeType("application/json");
		rawFile.open("GET", file, true);
		rawFile.onreadystatechange = function (){
			if (rawFile.readyState === 4  && rawFile.status === 200){
				callback(rawFile.responseText);
			}
		}
		rawFile.send(null);
	}




</script>
</body>
</html>
